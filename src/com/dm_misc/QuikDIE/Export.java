package com.dm_misc.QuikDIE;
/* ============================================================================
 * QuikDIE - Quik Documentum Import/Export
 * Export Content Module
 * (c) 2013-2015 MS Roth
 * 
 * This application will export content and metadata from a Documentum
 * repository according to the query contained in the export.properties
 * file.  The content will be exported in its native format and named
 * according to its r_object_id.  A companion XML file will also be created
 * to house the content's metadata.  The XML file will be named 
 * according to the content's r_object_id also.  Finally, if any of the objects
 * exported are of custom types (i.e., do not start with 'dm_', an XML
 * file will be created containing definitions for the type's custom attributes.
 * 
 * As is implied by the name of this application, there is an envisioned import
 * application that will read the type definition, metadata, and content files
 * generated by this application and import them into Documentum.  That
 * application does not exist yet.
 * 
 * Tested on Documentum Content Server 6.5, 6.7, 7.0, 7.1.
 * 
 * Sample export.properties file:
 *   export.query=select * from dm_sysobject where folder('/Temp',descend)
 *   export.user=dmadmin
 *   export.password=dmadmin
 *   export.repo=repo1
 *   export.path=c:/Temp/Export
 *   export.log=c:/Temp/Export/export.log
 * 
 * Notes:
 *   - the password will be encrypted and written back to the properties file 
 *     after the first run
 *   - even though the query in the sample will traverse a folder structure, all
 *     exported files will be written to a flat export destination as defined
 *     by the path property.
 *   
 * Sample metadata XML file:
 * <?xml version="1.0" encoding="UTF-8" standalone="yes" ?>
 * <object r_object_id="09003afd804f2ba8" content="true" virtdoc="true">
 *   <properties>
 *     <property name="r_object_type" type="string">dm_document</property>
 *     <property name="object_name" type="string">DUMMY_DOCUMENT_temp</property>
 *     <property name="title" type="string"></property>
 *     <property name="subject" type="string"></property>
 *     <property name="acl_domain" type="string">dmadmin</property>
 *     <property name="acl_name" type="string">dm_45003afd80008d08</property>
 *     <property name="owner_name" type="string">dmadmin</property>
 *     <property name="r_version_label" type="string">1.1</property>
 *     <property name="a_content_type" type="string">crtext</property>
 *     <property name="i_chronicle_id" type="string">09003afd804f2ba8</property>
 *     <property name="a_antecedent_id" type="string">09003afd804f2ba8</property>
 *   </properties>
 *   <repo_path>/Temp</repo_path>
 *   <content_file>09003afd804f2ba8.txt</content_file>
 *   <vd_children>
 *     <vd_child>09003afd80000210</vd_child>
 *     <vd_child>09003afd804e9914</vd_child>
 *   </vd_children>
 * </object>
 *       
 * Notes:
 *   - the properties shown are the default properties exported.  If this object
 *     had been a custom type with custom attributes, those would have been
 *     included here also.
 *   - this example is a virtual document, thus the virtdoc="true" XML attribute
 *     in the object element and the inclusion of the vd_children element.   
 *          
 * Sample type definition file:
 * <?xml version="1.0" encoding="UTF-8" standalone="yes" ?>
 * <type name="sr_document" super_type="dm_document" custom_attrs="3">
 *   <attributes>
 *     <attribute name="cat_id" type="STRING" size="12" repeating="false" />
 *     <attribute name="cat_tags" type="STRING" size="24" repeating="true" />
 *     <attribute name="expired" type="BOOLEAN" size="0" repeating="false" />
 *   </attributes>
 * </type>
 *          
 *   
 * Versions:
 *   1.0 - 2013-05-09 - initial release.
 *   1.1 - 2013-05-09 - added code to omit certain Documentum objects from
 *                      being considered as custom types.  
 *   1.2 - 2013-07-17 - included i_chronicle_id so version tree can be 
 *                      reconstructed.  Changed version attr to r_version_label
 *                      and object_type to r_object_type.  Added content_file
 *                      to xml output.
 *   1.3 - 2014-04-09 - included r_creator_name, r_creation_date, r_modifier,
 *                      r_modify_date as base metadata (thanks Malcolm MacArthur)
 *                    - clean Strings before writing them to XML file (thanks 
 *                      Malcolm MacArthur)
 *                    - updated dmRecordSet to v1.2
 *   1.4 - 2015-03-25 - Recompiled using Java 7
 *                    - updated JDOM library to 2.0.6    
 *                    - checks for supported version of DFC    
 *                    - export a_antecedent_id so version tree can be reconstructed  
 *                    - updated batch file to use dctm.jar   
 *   1.5 - 2015-07-02 - added additional code to detect content "parked" on BOCS 
 *                      server
 *                    - added "dmi" extension to object types ignored  
 *                    - implemented DCTMBasics JAR                    
 * ============================================================================        
 */

import java.io.File;
import java.io.PrintWriter;
import java.util.Date;
import java.util.HashSet;
import java.util.Set;

import com.dm_misc.collections.dmRecordSet;
import com.dm_misc.dctm.DCTMBasics;

import com.documentum.fc.client.*;
import com.documentum.fc.client.IDfTypedObject;
import com.documentum.fc.common.*;

import com.dm_misc.QuikDIE.Utils;

public class Export {

    private Set<String> m_ObjTypeSet = new HashSet<String>();
    private static final String BANNER = "\n\n" + Utils.APP_BANNER + "\n" + Utils.COPYRIGHT + "\n\n"
            + "Export Content Module v" + Utils.EXPORT_VERSION + "\n"
            + "==================================================";

    /*
     * ignore passed arguments 
     */
    public static void main(String[] args) {

        try {
            System.out.println(BANNER);
            System.out.println(new Date().toString());
            Export export = new Export(args);
            export.run();
        } catch (Exception e) {
            System.out.println("ERROR: " + e.getMessage());
            e.printStackTrace();
        }
    }

    /*
     * ignore passed arguments
     */
    private Export(String[] args) {
        // noop
    }

    /*
     * The run method contains the main process loop for the export.  After the
     * properties are read and verified, the query is executed to find the
     * objects to export.  An ExportObj is created for each r_object_id returned
     * by the query.  The ExportObj does the all the hard work of exporting.
     * Along the way, custom type definitions are collected for processing at the
     * end.
     */
    public void run() throws Exception {

        //IDfClientX cx = new DfClientX();
        
        // check if DFC version is supported
        if (!DCTMBasics.checkDFCversion(6.5))
        	throw new Exception ("Only DFC v6.5 and higher is supported");
              
        //IDfClient client = cx.getLocalClient();
        //IDfSessionManager sessionMgr = client.newSessionManager();
        IDfSession session = null;
        int objCount = 0;

        // read properties file
        if (!Utils.loadConfig(this.getClass(), Utils.EXPORT_PROPERTY_FILE)) {
            throw new Exception("Could not load configuration");
        }

        // validate export path
        if (!Utils.validateFileSystemPath(Utils.getProperty(Utils.EXPORT_PATH_KEY), true)) {
            throw new Exception("Problem with export path: " + Utils.getProperty(Utils.EXPORT_PATH_KEY));
        } else {
            System.out.println("Export path: " + Utils.getProperty(Utils.EXPORT_PATH_KEY));
        }

        // create log file
        if (!Utils.createLogFile(Utils.EXPORT_LOG_KEY)) {
            throw new Exception("Could not create log file: " + Utils.getProperty(Utils.EXPORT_LOG_KEY));
        } else {
            System.out.println("Export log: " + Utils.getProperty(Utils.EXPORT_LOG_KEY));
        }

        // check encrypted password
        Utils.checkPassword(Utils.OP_EXPORT);

        // login
        //session = Utils.login(Utils.getProperty(Utils.EXPORT_DOCBASE_KEY), Utils.getProperty(Utils.EXPORT_USER_KEY), Utils.getProperty(Utils.EXPORT_PASSWORD_KEY), sessionMgr);
        session = DCTMBasics.logon(Utils.getProperty(Utils.EXPORT_DOCBASE_KEY), Utils.getProperty(Utils.EXPORT_USER_KEY), Utils.getProperty(Utils.EXPORT_PASSWORD_KEY));
        if (session == null) {
            throw new Exception("Could not establish session with " + Utils.getProperty(Utils.EXPORT_DOCBASE_KEY));
        } else {
            System.out.println("Login successful:  " + Utils.getProperty(Utils.EXPORT_USER_KEY) + "@" + Utils.getProperty(Utils.EXPORT_DOCBASE_KEY));
        }

        // validate query
        if (!validateQuery(Utils.getProperty(Utils.EXPORT_QUERY_KEY))) {
            throw new Exception("Query must start with: SELECT R_OBJECT_ID or SELECT *");
        }

        // write log file header
        Utils.writeLog(BANNER);
        Utils.writeLog(new Date().toString());
        Utils.writeLog(Utils.dumpProperties(false));
        Utils.writeLog("");

        // run export query
        //IDfCollection col = Utils.runQuery(Utils.getProperty(Utils.EXPORT_QUERY_KEY), session);
        IDfCollection col = DCTMBasics.runSelectQuery(Utils.getProperty(Utils.EXPORT_QUERY_KEY), session);
        dmRecordSet dmRS = new dmRecordSet(col);
        col.close();

        if (dmRS.isEmpty()) {
            throw new Exception("Query returned 0 objects to process");
        } else {
            System.out.println("Found " + dmRS.getRowCount() + " objects to export...\n");
            Utils.writeLog("Found " + dmRS.getRowCount() + " objects to export...\n");
        }

        // process result set
        while (dmRS.hasNext()) {

            // get obj from collection
            IDfTypedObject tObj = dmRS.getNextRow();

            // create export obj
            ExportObj expObj = new ExportObj(tObj.getString("r_object_id"), Utils.getProperty(Utils.EXPORT_PATH_KEY), session);

            // export the obj
            boolean success = expObj.exportContent();
            if (success) {
                objCount++;
            }

            // check for custom types
            if (!Utils.omitTypes(expObj.getTypeName())) {
                if (!m_ObjTypeSet.contains(expObj.getTypeName())) // add custom types to be processed later				
                {
                    m_ObjTypeSet.add(expObj.getTypeName());
                }
            }
        }

        // export custom type defs
        exportTypeDefinitions(session);

        if (session != null) {
            session.getSessionManager().release(session);
        }

        System.out.println("\nExported " + objCount + " objects.");
        System.out.println(new Date().toString());
        Utils.writeLog("\nExported " + objCount + " objects.");
        Utils.writeLog(new Date().toString());
        Utils.closeLogFile();
        System.out.println("Done.");
    }

    /*
     * Ensure the query string will return the r_object_id at a minimum.
     * We need the r_object_id to instantiate ExportObjs.
     */
    private boolean validateQuery(String query) throws Exception {
        String temp = "";

        int sIndex = query.toLowerCase().indexOf("select");
        int fIndex = query.toLowerCase().indexOf("from");

        if (sIndex > -1 && fIndex > -1) {
            temp = query.toLowerCase().substring(sIndex, fIndex);
        } else {
            return false;
        }

        // query must return r_object_id in result set
        if ((temp.indexOf("r_object_id")) < 0 && (temp.indexOf("*") < 0)) {
            return false;
        } else {
            return true;
        }
    }

    /*
     * Create XML files that contain the details of custom object types exported.
     * The list of custom object types found during the content export is in the
     * m_ObjTypeSet ArrayList.  XML files are created for each type that describe
     * their custom attributes.
     */
    private void exportTypeDefinitions(IDfSession session) throws Exception {
        String path = Utils.getProperty(Utils.EXPORT_PATH_KEY);
        String template = "<attribute name=\"%s\" type=\"%s\" size=\"%d\" repeating=\"%s\" />";

        for (String type : m_ObjTypeSet) {
            IDfType typeObj = session.getType(type);
            String filename = type + Utils.TYPEDEF_FILE_EXT;

            System.out.println("Type definition: " + type + " ==> " + filename);
            Utils.writeLog("Type definition: " + type + " ==> " + filename);

            // open output file
            File file = new File(path + "/" + filename);
            PrintWriter xmlFile = new PrintWriter(file);

            // get custom attrs
            int attrcnt = typeObj.getInt("attr_count") - typeObj.getInt("start_pos");

            try {
                // write xml file header
                xmlFile.println("<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\" ?>");
                xmlFile.print("<type name=\"" + type + "\" super_type=\"" + typeObj.getSuperName() + "\" custom_attrs=\"" + attrcnt + "\"");
                xmlFile.println(">");
                xmlFile.println("<attributes>");

                // loop over custom attrs
                if (attrcnt > 0) {
                    for (int i = 0; i < attrcnt; i++) {
                        int offset = typeObj.getInt("start_pos") + i;
                        IDfAttr attrObj = typeObj.getTypeAttr(offset);

                        // write custom attrs to xml file
                        xmlFile.println(String.format(template, attrObj.getName(), Utils.DATA_TYPES[attrObj.getDataType()], attrObj.getLength(), Boolean.valueOf(attrObj.isRepeating()).toString()));
                    }
                }

                xmlFile.println("</attributes>");
                xmlFile.println("</type>");
            } catch (Exception e) {
                throw new Exception(e.getMessage());
            } finally {
                xmlFile.close();
            }
        }
    }
}

/* ============================================================================
 * <SDG><
 * ============================================================================
 */
